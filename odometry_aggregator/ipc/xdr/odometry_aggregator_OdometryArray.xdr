%{
#include <ipc_bridge/msgs/roslib_Header.h>
#include <ipc_bridge/msgs/nav_msgs_Odometry.h>
%}

ipc_type roslib_Header;
ipc_type nav_msgs_Odometry;

struct odometry_aggregator_OdometryArray
{
 roslib_Header header;
 unsigned int array_length;
 nav_msgs_Odometry array<>;

%{
  odometry_aggregator_OdometryArray() : array_length(0), array(0) {}
  odometry_aggregator_OdometryArray(const odometry_aggregator_OdometryArray& msg) :
    header(msg.header), array_length(msg.array_length)
  {
    if (array != 0)
      delete[] array;
  
    array = 0;
    if (msg.array_length > 0)
      {
        array = new nav_msgs_Odometry[array_length];
        for (unsigned int i = 0; i < array_length; i++)
            array[i] = msg.array[i];           
      }
  }
  ~odometry_aggregator_OdometryArray()
  {
    if (array != 0)
      delete[] array;
  }
  odometry_aggregator_OdometryArray& operator= (const odometry_aggregator_OdometryArray& msg)
  {
    header = msg.header;
    array_length = msg.array_length;
    
    if (array != 0)
      delete[] array;
  
    array = 0;
    if (msg.array_length > 0)
      {
        array = new nav_msgs_Odometry[array_length];
        for (unsigned int i = 0; i < array_length; i++)
            array[i] = msg.array[i];           
      }

    return *this;
  }
%}
};

%{
namespace ipc_bridge
{
    namespace odometry_aggregator
    {
        typedef odometry_aggregator_OdometryArray OdometryArray;
    }
}
%}
